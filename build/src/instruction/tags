!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
add_reg	instruction.c	/^void add_reg(cpu *core, instruction i) {$/;"	f
cc_jump_relative	instruction.c	/^void cc_jump_relative(cpu *core, instruction i, uint8_t mask, bool set) {$/;"	f
check_carry8_shift	instruction.c	/^bool check_carry8_shift(uint8_t v1, bool left_shift) {$/;"	f
check_daa	instruction.c	/^void check_daa(cpu *core, uint8_t rv) {$/;"	f
check_half_carry16	instruction.c	/^bool check_half_carry16(uint16_t v1, uint16_t v2, bool is_add) {$/;"	f
check_half_carry8	instruction.c	/^bool check_half_carry8(uint8_t v1, uint8_t v2, bool is_add) {$/;"	f
check_zero	instruction.c	/^bool check_zero(uint16_t v) { return v == 0; }$/;"	f
exec_next_instruction	instruction.c	/^instruction exec_next_instruction(cpu *core, uint8_t opcode) {$/;"	f
halt	instruction.c	/^void halt(cpu *core, instruction i) {$/;"	f
handle_add8_reg	instruction.c	/^void handle_add8_reg(cpu *core, uint8_t og_src, enum reg_enum dst_reg,$/;"	f
handle_add_carry	instruction.c	/^bool handle_add_carry(cpu *core, uint8_t *src) {$/;"	f
handle_sub8_reg	instruction.c	/^void handle_sub8_reg(cpu *core, uint8_t og_src, enum reg_enum dst_reg,$/;"	f
is_arithmetic_carry	instruction.c	/^bool is_arithmetic_carry(instruction i) { return (i.opcode & 0x0f) > 0x07; }$/;"	f
jump_relative	instruction.c	/^void jump_relative(cpu *core, instruction i, int8_t offset) {$/;"	f
load_reg	instruction.c	/^void load_reg(cpu *core, instruction i) {$/;"	f
new_args	instruction.c	/^arguments new_args(enum reg_enum src_reg, enum reg_enum dst_reg,$/;"	f
noop	instruction.c	/^void noop(cpu *core, instruction i) { return; }$/;"	f
set_instruction_vars	instruction.c	/^void set_instruction_vars(cpu *core, instruction *i, uint8_t len,$/;"	f
shift_reg	instruction.c	/^void shift_reg(cpu *core, instruction i, bool left_shift) {$/;"	f
stack_pop_i	instruction.c	/^void stack_pop_i(cpu *core, instruction i) {$/;"	f
stop_cpu	instruction.c	/^void stop_cpu(cpu *core, instruction i) { core->state = _STOP; }$/;"	f
sub_reg	instruction.c	/^void sub_reg(cpu *core, instruction i) {$/;"	f
